
-- Admin roole management
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'admin_role') THEN
        CREATE TYPE admin_role AS ENUM ('superadmin', 'admin');
    END IF;
END$$;


-- Create ADMIN USER TABLE
create table public.admin (
  user_id uuid not null,
  role public.admin_role not null,
  created_at timestamp with time zone null default now(),
  id integer generated by default as identity not null,
  constraint admin_pkey primary key (user_id),
  constraint admin_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;



-- Function to check if user exists

CREATE OR REPLACE FUNCTION check_user_exists(email_input TEXT)
RETURNS TEXT
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
AS $$
DECLARE
  existing_user RECORD;
BEGIN
  -- Select user from auth.users with case-insensitive email comparison
  SELECT id, email, email_confirmed_at INTO existing_user
  FROM auth.users
  WHERE LOWER(email) = LOWER(TRIM(email_input));

  -- Check if user exists and is verified (email_confirmed_at is not NULL)
  IF existing_user IS NOT NULL AND existing_user.email_confirmed_at IS NOT NULL THEN
    RETURN 'User Already Exists. Please Login';
  END IF;

  -- Return 'OK' if user doesn't exist or isn't verified
  RETURN 'OK';
END;
$$;

-- Step 2: Grant execute permission to public roles
GRANT EXECUTE ON FUNCTION check_user_exists(TEXT) TO anon;
GRANT EXECUTE ON FUNCTION check_user_exists(TEXT) TO authenticated;



-- Step 3: Enable Row-Level Security
ALTER TABLE admin ENABLE ROW LEVEL SECURITY;

-- Step 4: Create a policy to allow SELECT for all authenticated users
CREATE POLICY "Allow read access to admins"
ON admin
FOR SELECT
USING (auth.uid() IS NOT NULL);

-- Step 5: Create policy to allow only superadmins to INSERT
CREATE POLICY "Only superadmin can insert admins"
ON admin
FOR INSERT
WITH CHECK (
    EXISTS (
        SELECT 1 FROM admin AS a
        WHERE a.user_id = auth.uid() AND a.role = 'superadmin'
    )
);

-- Step 6: Create policy to allow only superadmins to UPDATE
CREATE POLICY "Only superadmin can update admins"
ON admin
FOR UPDATE
USING (
    EXISTS (
        SELECT 1 FROM admin AS a
        WHERE a.user_id = auth.uid() AND a.role = 'superadmin'
    )
);

-- Step 7: Create policy to allow only superadmins to DELETE
CREATE POLICY "Only superadmin can delete admins"
ON admin
FOR DELETE
USING (
    EXISTS (
        SELECT 1 FROM admin AS a
        WHERE a.user_id = auth.uid() AND a.role = 'superadmin'
    )
);




-- Create RPC function to fetch admin users with details from users table, excluding a specified user_id
-- DROP FUNCTION get_admin_users(uuid);
-- DROP FUNCTION get_admin_user_by_id(uuid);
-- CREATE OR REPLACE FUNCTION get_admin_users(exclude_user_id UUID DEFAULT NULL)
-- RETURNS TABLE (
--   id UUID,
--   email TEXT,
--   first_name TEXT,
--   last_name TEXT,
--   phone TEXT,
--   role TEXT
-- ) AS $$
-- BEGIN
--   RETURN QUERY
--   SELECT 
--     u.id::UUID,
--     u.email::TEXT,
--     u.first_name::TEXT,
--     u.last_name::TEXT,
--     u.phone::TEXT,
--     a.role::TEXT
--   FROM admin a
--   INNER JOIN users u ON a.user_id = u.id
--   WHERE exclude_user_id IS NULL OR u.id != exclude_user_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Create RPC function to fetch single admin user by ID
-- CREATE OR REPLACE FUNCTION get_admin_user_by_id(user_id UUID)
-- RETURNS TABLE (
--   id UUID,
--   email TEXT,
--   first_name TEXT,
--   last_name TEXT,
--   phone TEXT,
--   role TEXT
-- ) AS $$
-- BEGIN
--   RETURN QUERY
--   SELECT 
--     u.id::UUID,
--     u.email::TEXT,
--     u.first_name::TEXT,
--     u.last_name::TEXT,
--     u.phone::TEXT,
--     a.role::TEXT
--   FROM admin a
--   INNER JOIN users u ON a.user_id = u.id
--   WHERE a.user_id = $1;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Grant necessary permissions
-- GRANT EXECUTE ON FUNCTION get_admin_users(UUID) TO authenticated;
-- GRANT EXECUTE ON FUNCTION get_admin_user_by_id(UUID) TO authenticated;
-- Remove anon access for security
-- GRANT EXECUTE ON FUNCTION get_admin_users(UUID) TO anon;
-- GRANT EXECUTE ON FUNCTION get_admin_user_by_id(UUID) TO anon;



-- TRIGGER TO INSERT USER IN ADMIN


CREATE OR REPLACE FUNCTION create_admin_user()
RETURNS TRIGGER AS $$
BEGIN
  -- Insert new admin record when a user is created
  INSERT INTO public.admin (
    user_id,
    role,
    first_name,
    last_name
  )
  VALUES (
    NEW.id,
    'user'::public.admin_role, -- Set default role, adjust as needed
    COALESCE(NEW.raw_user_meta_data->>'first_name', ''),
    COALESCE(NEW.raw_user_meta_data->>'last_name', '')
  );
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create the trigger on auth.users table
CREATE TRIGGER trigger_create_admin_user
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION create_admin_user();